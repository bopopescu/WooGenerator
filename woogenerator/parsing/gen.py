"""
CsvParseGenTree
Introduces the "Generator" structure to the heirarchical CSV parser class CsvParseTree.

The Generator structure attaches metadata like code, name and description for all objects.
In heirarchical structures, the metadata for an object is generated by ananlysing its ancestors.
"""

from __future__ import absolute_import

from collections import OrderedDict

from ..utils import DescriptorUtils, Registrar, SanitationUtils, SeqUtils
from .tree import (CsvParseTree, ImportTreeItem, ImportTreeObject,
                   ImportTreeTaxo)


class ImportGenMixin(object):
    "Provides basic Generator interface for Import classes as a mixin"
    codesumKey = 'codesum'
    descsumKey = 'descsum'
    namesumKey = 'itemsum'
    namesum = DescriptorUtils.safe_key_property(namesumKey)
    codesum = DescriptorUtils.safe_key_property(codesumKey)
    descsum = DescriptorUtils.safe_key_property(descsumKey)

    verifyMetaKeys = [
        namesumKey,
        codesumKey,
        descsumKey,
    ]

    # def __init__(self, *args, **kwargs):
    #     if self.DEBUG_MRO:
    #         self.register_message(' ')
    #     super(ImportGenMixin, self).__init__(*args, **kwargs)

    @property
    def index(self):
        index = self.codesum
        super_obj = super(ImportGenMixin, self)
        if hasattr(super_obj, 'index'):
            index = '|'.join([
                super_obj.index,
                index
            ])
        return index

    def __str__(self):
        return "%10s <%s>" % (
            '|'.join(i for i in [self.codesum, self.namesum] if i), self.type_name)


class ImportGenObject(ImportTreeObject, ImportGenMixin):
    "Base class for heirarchical generator classes"

    codeKey = 'code'
    nameKey = 'name'
    fullnameKey = 'fullname'
    description_key = 'HTML Description'
    fullnamesumKey = 'fullnamesum'

    verifyMetaKeys = ImportTreeObject.verifyMetaKeys + ImportGenMixin.verifyMetaKeys

    code = DescriptorUtils.safe_key_property(codeKey)
    name = DescriptorUtils.safe_key_property(nameKey)
    fullname = DescriptorUtils.safe_key_property(fullnameKey)
    description = DescriptorUtils.safe_key_property(description_key)
    fullnamesum = DescriptorUtils.safe_key_property(fullnamesumKey)

    name_delimeter = ' '

    index = ImportGenMixin.index

    def __init__(self, *args, **kwargs):
        if self.DEBUG_MRO:
            self.register_message('ImportGenObject')
        self.subs = kwargs.pop('subs', {})
        self.regex = kwargs.pop('regex', {})
        super(ImportGenObject, self).__init__(*args, **kwargs)

    @property
    def name_ancestors(self):
        return self.ancestors

    def get_code_delimeter(self, other):  # pylint: disable=no-self-use,unused-argument
        return ''

    def join_codes(self, ancestors):
        code_ancestors = [
            ancestor for ancestor in ancestors + [self] if ancestor.code]
        if not code_ancestors:
            return ""
        prev = code_ancestors.pop(0)
        codesum = prev.code
        while code_ancestors:
            this = code_ancestors.pop(0)
            codesum += this.get_code_delimeter(prev) + this.code
            prev = this
        return codesum

    def join_descs(self, ancestors):
        if self.DEBUG_GEN:
            self.register_message(
                u"given description: {}".format(self.description))
            self.register_message(u"self: {}".format(self.items()))
        if self.description:
            return self.description
        fullnames = [self.fullname]
        for ancestor in reversed(ancestors):
            ancestor_description = ancestor.description
            if ancestor_description:
                return ancestor_description
            ancestor_fullname = ancestor.fullname
            if ancestor_fullname:
                fullnames.insert(0, ancestor_fullname)
        if fullnames:
            return " - ".join(reversed(fullnames))
        else:
            return ""

    def join_names(self, ancestors):
        ancestors_self = ancestors + [self]
        names = SeqUtils.filter_unique_true(
            map(lambda x: x.name, ancestors_self))
        name_delimeter = self.name_delimeter
        return name_delimeter.join(names)

    def join_fullnames(self, ancestors):
        ancestors_self = ancestors + [self]
        names = SeqUtils.filter_unique_true(
            map(lambda x: x.fullname, ancestors_self))
        name_delimeter = self.name_delimeter
        return name_delimeter.join(names)

    def change_name(self, name):
        return SanitationUtils.shorten(self.regex, self.subs, name)

    def process_meta(self):
        if self.DEBUG_MRO:
            self.register_message(' ')
        # super(ImportGenObject, self).process_meta()
        meta = self.meta

        try:
            self.fullname = meta[0]
        except IndexError:
            self.fullname = ""
        # self.register_message("fullname: {}".format(self.fullname ) )

        try:
            self.code = meta[1]
        except IndexError:
            self.code = ""
        # self.register_message("code: {}".format(self.code ) )

        ancestors = self.ancestors
        if self.DEBUG_GEN:
            self.register_message('ancestors:')
            for ancestor in ancestors:
                self.register_message(u"-> {}".format(ancestor))

        codesum = self.join_codes(ancestors)
        if self.DEBUG_GEN:
            self.register_message(u"codesum: {}".format(codesum))
        self.codesum = codesum

        descsum = self.join_descs(ancestors)
        if self.DEBUG_GEN:
            self.register_message(u"descsum: {}".format(descsum))
        self.descsum = descsum

        name = self.change_name(self.fullname)
        if self.DEBUG_GEN:
            self.register_message(u"name: {}".format(name))
        self.name = name

        name_ancestors = self.name_ancestors

        namesum = self.join_names(name_ancestors)
        if self.DEBUG_GEN:
            self.register_message(u"namesum: {}".format(namesum))
        self.namesum = namesum

        fullnamesum = self.join_fullnames(name_ancestors)
        if self.DEBUG_GEN:
            self.register_message(u"fullnamesum: {}".format(fullnamesum))
        self.fullnamesum = fullnamesum


class ImportGenItem(ImportGenObject, ImportTreeItem):
    "Class for items in generator heirarchy"

    @property
    def name_ancestors(self):
        return self.item_ancestors

    def get_name_ancestors(self):
        exc = DeprecationWarning(
            "use .name_ancestors instead of .get_name_ancestors()")
        self.register_error(exc)
        return self.name_ancestors
        # return self.getItemAncestors()

    def get_code_delimeter(self, other):
        assert issubclass(type(other), ImportGenObject)
        if not other.isRoot and other.isTaxo:
            return '-'
        else:
            return super(ImportGenItem, self).get_code_delimeter(other)


class ImportGenTaxo(ImportGenObject, ImportTreeTaxo):

    namesumKey = 'taxosum'
    namesum = DescriptorUtils.safe_key_property(namesumKey)

    name_delimeter = ' > '

    def get_name_delimeter(self):
        exc = DeprecationWarning(
            "use .name_delimeter instead of .get_name_delimeter()")
        self.register_error(exc)
        return ' > '


class CsvParseGenMixin(object):
    """
    Mixin class for parsers with generator interface
    """
    objectContainer = ImportGenObject
    taxoContainer = ImportGenTaxo
    itemContainer = ImportGenItem
    # productContainer = ImportGenProduct
    containers = {}

    @classmethod
    def get_code_sum(cls, object_data):
        assert issubclass(type(object_data), ImportGenMixin)
        return object_data.codesum

    @classmethod
    def get_name_sum(cls, object_data):
        assert issubclass(type(object_data), ImportGenMixin)
        return object_data.namesum

    @classmethod
    def get_full_name_sum(cls, object_data):
        assert issubclass(type(object_data), ImportGenObject)
        return object_data.fullnamesum

    @classmethod
    def sanitize_cell(cls, cell):
        return SanitationUtils.sanitize_cell(cell)

    def get_parser_data(self, **kwargs):  # pylint: disable=unused-argument
        if Registrar.DEBUG_MRO:
            Registrar.register_message(' ')
        defaults = {
            self.objectContainer.namesumKey: '',
            self.objectContainer.codesumKey: '',
            self.objectContainer.descsumKey: ''
        }
        # super_data = super(CsvParseGenMixin, self).get_parser_data(**kwargs)
        # super_data = {}
        # defaults.update(super_data)
        return defaults

class CsvParseGenTree(CsvParseTree, CsvParseGenMixin):
    """ Parser for tree-based generator structure """

    sanitize_cell = CsvParseGenMixin.sanitize_cell
    objectContainer = CsvParseGenMixin.objectContainer
    taxoContainer = CsvParseGenMixin.taxoContainer
    itemContainer = CsvParseGenMixin.itemContainer

    def __init__(self, cols, defaults, schema, **kwargs):
        if self.DEBUG_MRO:
            self.register_message('CsvParseGenTree')
        taxo_subs = kwargs.pop('taxo_subs', {})
        item_subs = kwargs.pop('item_subs', {})
        extra_defaults = OrderedDict([
            ('CVC', '0'),
            ('code', ''),
            ('name', ''),
            ('fullname', ''),
            ('description', ''),
            ('HTML Description', ''),
            ('imglist', [])
        ])
        extra_taxo_subs = OrderedDict([
            ('', ''),
        ])
        extra_item_subs = OrderedDict([
            ('Hot Pink', 'Pink'),
            ('Hot Lips (Red)', 'Red'),
            ('Hot Lips', 'Red'),
            ('Silken Chocolate (Bronze)', 'Bronze'),
            ('Silken Chocolate', 'Bronze'),
            ('Moon Marvel (Silver)', 'Silver'),
            ('Dusty Gold', 'Gold'),

            ('Screen Printed', ''),
            ('Embroidered', ''),
        ])
        extra_cols = [schema]

        cols = SeqUtils.combine_lists(cols, extra_cols)
        defaults = SeqUtils.combine_ordered_dicts(defaults, extra_defaults)

        kwargs['meta_width'] = kwargs.get('meta_width', 2)
        assert kwargs['meta_width'] >= 2, "meta_width must be greater than 2 for a GEN subclass"

        super(CsvParseGenTree, self).__init__(cols, defaults, **kwargs)
        # CsvParseGenMixin.__init__(self, schema)


        self.schema = schema
        self.taxo_subs = SeqUtils.combine_ordered_dicts(
            taxo_subs, extra_taxo_subs)
        self.item_subs = SeqUtils.combine_ordered_dicts(
            item_subs, extra_item_subs)
        self.taxo_regex = SanitationUtils.compile_regex(self.taxo_subs)
        self.item_regex = SanitationUtils.compile_regex(self.item_subs)

        if self.DEBUG_GEN:
            self.register_message("taxo_depth: {}".format(
                self.taxo_depth), 'CsvParseGenTree.__init__')
            self.register_message("item_depth: {}".format(
                self.item_depth), 'CsvParseGenTree.__init__')
            self.register_message("max_depth: {}".format(
                self.max_depth), 'CsvParseGenTree.__init__')
            self.register_message("meta_width: {}".format(
                self.meta_width), 'CsvParseGenTree.__init__')
            self.register_message("schema: {}".format(
                self.schema), 'CsvParseGenTree.__init__')

    def get_new_obj_container(self, all_data, **kwargs):
        if self.DEBUG_MRO:
            self.register_message(' ')
        container = super(CsvParseGenTree, self).get_new_obj_container(
            all_data, **kwargs)
        if issubclass(container, ImportTreeItem):
            if self.DEBUG_GEN:
                self.register_message("super resulted in item container")
            itemtype = all_data.get(self.schema, '')
            if self.DEBUG_GEN:
                self.register_message("itemtype: {}".format(itemtype))
            if itemtype in self.containers.keys():
                container = self.containers[itemtype]
        else:
            if self.DEBUG_GEN:
                self.register_message("super resulted in non-item container")
        return container

    def get_parser_data(self, **kwargs):
        super_data = CsvParseGenMixin.get_parser_data(self, **kwargs)
        super_data.update(CsvParseTree.get_parser_data(self, **kwargs))
        return super_data

    # def clear_transients(self):
    #     super(CsvParseGenTree, self).clear_transients()
        # CSVParse_Shop.clear_transients(self)

    # def register_item(self, item_data):
    #     super(CsvParseGenTree, self).register_item(item_data)
    #     if item_data.isProduct:
    #         self.register_product(item_data)

    def change_item(self, item):
        return SanitationUtils.shorten(self.item_regex, self.item_subs, item)

    def change_fullname(self, item):  # pylint: disable=no-self-use
        subs = OrderedDict([(' \xe2\x80\x94 ', ' ')])
        return SanitationUtils.shorten(
            SanitationUtils.compile_regex(subs), subs, item)

    def get_kwargs(self, all_data, container, **kwargs):
        if self.DEBUG_MRO:
            self.register_message(' ')
        kwargs = super(CsvParseGenTree, self).get_kwargs(
            all_data, container, **kwargs)
        assert issubclass(container, ImportGenObject)
        if issubclass(container, self.taxoContainer):
            regex = self.taxo_regex
            subs = self.taxo_subs
        else:
            assert \
                issubclass(container, self.itemContainer), \
                "class must be item or taxo subclass not %s" % container.__name__
            regex = self.item_regex
            subs = self.item_subs
        kwargs['regex'] = regex
        kwargs['subs'] = subs
        for key in ['regex', 'subs']:
            assert kwargs[key] is not None
        return kwargs

    # def new_object(self, rowcount, row, **kwargs):
    # return super(CsvParseGenTree, self).new_object(rowcount, row, **kwargs)
