"""
CSVParse_Gen_Tree
Introduces the "Generator" structure to the heirarchical CSV parser class CSVParse_Tree
and flat CSV parser class, CSVParse_Flat along with thier respective helper classses.
The Generator structure attaches metadata like code, name and description for all objects.
In heirarchical structures, the metadata for an object is generated by ananlysing its ancestors.
This allows a common metadata interface to be shared between heirarchical and nonheirarchical structures.
Should be dimensionally agnostic (doesn't know if using flat or tree type) but isn't. so there are flat and tree versions
"""

from collections import OrderedDict

from woogenerator.utils import descriptorUtils, SanitationUtils, listUtils, Registrar
from woogenerator.parsing.abstract import ObjList, ImportObject, CSVParse_Base
from woogenerator.parsing.tree import CSVParse_Tree, ImportTreeItem, ImportTreeTaxo, ImportTreeObject
from woogenerator.parsing.flat import ImportFlat


# class GenProdList(ProdList):
#     def append(self, object_data):
#         assert issubclass(object_data.__class__, ImportGenProduct), \
#             "object must be subclass of ImportGenProduct not %s : %s" % (
#                 SanitationUtils.coerce_unicode(object_data.__class__),
#                 SanitationUtils.coerce_unicode(object_data)
#             )
#         return super(GenProdList, self).append(object_data)

# class GenItemList()
#
# class GenTaxoList(ObjList):
#     def append(self, object_data):
#         assert issubclass(object_data.__class__, ImportGenTaxo), \
#         "object must be subclass of ImportGenTaxo not %s : %s" % (
#         SanitationUtils.coerce_unicode(object_data.__class__),
#         SanitationUtils.coerce_unicode(object_data)
#         )
#         return super(GenTaxoList, self).append(object_data)

class ImportGenMixin(object):
    "Provides basic Generator interface for Import classes as a mixin"
    codesumKey = 'codesum'
    descsumKey = 'descsum'
    namesumKey = 'itemsum'
    namesum = descriptorUtils.safeKeyProperty(namesumKey)
    codesum = descriptorUtils.safeKeyProperty(codesumKey)
    descsum = descriptorUtils.safeKeyProperty(descsumKey)

    verifyMetaKeys = [
        namesumKey,
        codesumKey,
        descsumKey,
    ]

    # def __init__(self, *args, **kwargs):
    #     if self.DEBUG_MRO:
    #         self.registerMessage(' ')
    #     super(ImportGenMixin, self).__init__(*args, **kwargs)

    @property
    def index(self):
        index = self.codesum
        super_obj = super(ImportGenMixin, self)
        if hasattr(super_obj, 'index'):
            index = '|'.join([
                super_obj.index,
                index
            ])
        return index

    # @property
    # def verifyMetaKeys(self):
    #     return [
    #         self.namesumKey,
    #         self.codesumKey,
    #         self.descsumKey,
    #     ]

    def __str__(self):
        return "%10s <%s>" % (
            '|'.join(i for i in [self.codesum, self.namesum] if i), self.type_name)


class ImportGenFlat(ImportFlat, ImportGenMixin):
    index = ImportGenMixin.index

    "Base class for flat generator classes"
    # def __init__(self, *args, **kwargs):
    #     if self.DEBUG_MRO:
    #         self.registerMessage(' ')
    #     super(ImportGenFlat, self).__init__(*args, **kwargs)
    # self.verifyMeta()


class ImportGenObject(ImportTreeObject, ImportGenMixin):
    "Base class for heirarchical generator classes"

    codeKey = 'code'
    nameKey = 'name'
    fullnameKey = 'fullname'
    descriptionKey = 'HTML Description'
    fullnamesumKey = 'fullnamesum'

    verifyMetaKeys = ImportTreeObject.verifyMetaKeys + ImportGenMixin.verifyMetaKeys

    code = descriptorUtils.safeKeyProperty(codeKey)
    name = descriptorUtils.safeKeyProperty(nameKey)
    fullname = descriptorUtils.safeKeyProperty(fullnameKey)
    description = descriptorUtils.safeKeyProperty(descriptionKey)
    fullnamesum = descriptorUtils.safeKeyProperty(fullnamesumKey)

    name_delimeter = ' '

    index = ImportGenMixin.index

    def __init__(self, *args, **kwargs):
        if self.DEBUG_MRO:
            self.registerMessage('ImportGenObject')
        self.subs = kwargs.pop('subs', {})
        self.regex = kwargs.pop('regex', {})
        super(ImportGenObject, self).__init__(*args, **kwargs)

    @classmethod
    def from_import_tree_object(cls, object_data, regex, subs):
        raise DeprecationWarning()
        # assert isinstance(object_data, ImportTreeObject)
        # row = object_data.row
        # rowcount = object_data.rowcount
        # depth = object_data.getDepth()
        # meta = object_data.getMeta()
        # parent = object_data.getParent()
        # return cls(object_data, rowcount, row, depth, meta, parent, regex,
        # subs)

    # @property
    # def verifyMetaKeys(self):
    #     superVerifyMetaKeys = super(ImportGenObject, self).verifyMetaKeys
    #     superVerifyMetaKeys += ImportGenMixin.verifyMetaKeys
    #     return  superVerifyMetaKeys + [
    #         self.codeKey,
    #         self.nameKey,
    #         self.fullnameKey,
    #         self.fullnamesumKey
    #     ]

    # @property
    # def index(self):
    #     return self.codesum

    @property
    def name_ancestors(self):
        return self.ancestors

    def getNameAncestors(self):
        raise DeprecationWarning(
            "use .name_ancestors instead of .getNameAncestors()")
        return self.name_ancestors
        # return self.getAncestors()

    def get_code_delimeter(self, other):
        return ''

    def joinCodes(self, ancestors):
        code_ancestors = [
            ancestor for ancestor in ancestors + [self] if ancestor.code]
        if not code_ancestors:
            return ""
        prev = code_ancestors.pop(0)
        codesum = prev.code
        while code_ancestors:
            this = code_ancestors.pop(0)
            codesum += this.get_code_delimeter(prev) + this.code
            prev = this
        return codesum

    def joinDescs(self, ancestors):
        if self.DEBUG_GEN:
            self.registerMessage(
                u"given description: {}".format(self.description))
            self.registerMessage(u"self: {}".format(self.items()))
        if self.description:
            return self.description
        fullnames = [self.fullname]
        for ancestor in reversed(ancestors):
            ancestor_description = ancestor.description
            if ancestor_description:
                return ancestor_description
            ancestor_fullname = ancestor.fullname
            if ancestor_fullname:
                fullnames.insert(0, ancestor_fullname)
        if fullnames:
            return " - ".join(reversed(fullnames))
        else:
            return ""

    # @property
    # def name_delimeter(self):
    #     return ' '

    def getNameDelimeter(self):
        raise DeprecationWarning(
            "use .name_delimeter instead of .getNameDelimeter()")
        return ' '

    def joinNames(self, ancestors):
        ancestors_self = ancestors + [self]
        names = listUtils.filter_unique_true(
            map(lambda x: x.name, ancestors_self))
        name_delimeter = self.name_delimeter
        return name_delimeter.join(names)

    def joinFullnames(self, ancestors):
        ancestors_self = ancestors + [self]
        names = listUtils.filter_unique_true(
            map(lambda x: x.fullname, ancestors_self))
        name_delimeter = self.name_delimeter
        return name_delimeter.join(names)

    def change_name(self, name):
        return SanitationUtils.shorten(self.regex, self.subs, name)

    def processMeta(self):
        if self.DEBUG_MRO:
            self.registerMessage(' ')
        # super(ImportGenObject, self).processMeta()
        meta = self.meta

        try:
            self.fullname = meta[0]
        except IndexError:
            self.fullname = ""
        # self.registerMessage("fullname: {}".format(self.fullname ) )

        try:
            self.code = meta[1]
        except IndexError:
            self.code = ""
        # self.registerMessage("code: {}".format(self.code ) )

        ancestors = self.ancestors
        if self.DEBUG_GEN:
            self.registerMessage('ancestors:')
            for ancestor in ancestors:
                self.registerMessage(u"-> {}".format(ancestor))

        codesum = self.joinCodes(ancestors)
        if self.DEBUG_GEN:
            self.registerMessage(u"codesum: {}".format(codesum))
        self.codesum = codesum

        descsum = self.joinDescs(ancestors)
        if self.DEBUG_GEN:
            self.registerMessage(u"descsum: {}".format(descsum))
        self.descsum = descsum

        name = self.change_name(self.fullname)
        if self.DEBUG_GEN:
            self.registerMessage(u"name: {}".format(name))
        self.name = name

        name_ancestors = self.name_ancestors

        namesum = self.joinNames(name_ancestors)
        if self.DEBUG_GEN:
            self.registerMessage(u"namesum: {}".format(namesum))
        self.namesum = namesum

        fullnamesum = self.joinFullnames(name_ancestors)
        if self.DEBUG_GEN:
            self.registerMessage(u"fullnamesum: {}".format(fullnamesum))
        self.fullnamesum = fullnamesum


class ImportGenItem(ImportGenObject, ImportTreeItem):
    "Class for items in generator heirarchy"

    @property
    def name_ancestors(self):
        return self.itemAncestors

    def getNameAncestors(self):
        exc = DeprecationWarning(
            "use .name_ancestors instead of .getNameAncestors()")
        self.registerError(exc)
        return self.name_ancestors
        # return self.getItemAncestors()

    def get_code_delimeter(self, other):
        assert issubclass(type(other), ImportGenObject)
        if not other.isRoot and other.isTaxo:
            return '-'
        else:
            return super(ImportGenItem, self).get_code_delimeter(other)


class ImportGenTaxo(ImportGenObject, ImportTreeTaxo):

    namesumKey = 'taxosum'
    namesum = descriptorUtils.safeKeyProperty(namesumKey)

    name_delimeter = ' > '

    def getNameDelimeter(self):
        exc = DeprecationWarning(
            "use .name_delimeter instead of .getNameDelimeter()")
        self.registerError(exc)
        return ' > '


class CSVParse_Gen_Mixin(object):
    """
    Mixin class for parsers with generator interface
    """
    objectContainer = ImportGenObject
    taxoContainer = ImportGenTaxo
    itemContainer = ImportGenItem
    # productContainer = ImportGenProduct
    containers = {}

    @classmethod
    def get_code_sum(cls, object_data):
        assert issubclass(type(object_data), ImportGenMixin)
        return object_data.codesum

    @classmethod
    def getNameSum(cls, object_data):
        assert issubclass(type(object_data), ImportGenMixin)
        return object_data.namesum

    @classmethod
    def get_full_name_sum(cls, object_data):
        assert issubclass(type(object_data), ImportGenObject)
        return object_data.fullnamesum

    def sanitizeCell(self, cell):
        return SanitationUtils.sanitizeCell(cell)

    def getParserData(self, **kwargs):
        if Registrar.DEBUG_MRO:
            Registrar.registerMessage(' ')
        defaults = {
            self.objectContainer.namesumKey: '',
            self.objectContainer.codesumKey: '',
            self.objectContainer.descsumKey: ''
        }
        # super_data = super(CSVParse_Gen_Mixin, self).getParserData(**kwargs)
        # super_data = {}
        # defaults.update(super_data)
        return defaults


# , CSVParse_Shop):
class CSVParse_Gen_Tree(CSVParse_Tree, CSVParse_Gen_Mixin):
    """ Parser for tree-based generator structure """

    sanitizeCell = CSVParse_Gen_Mixin.sanitizeCell

    def __init__(self, cols, defaults, schema, **kwargs):
        if self.DEBUG_MRO:
            self.registerMessage('CSVParse_Gen_Tree')
        taxo_subs = kwargs.pop('taxo_subs', {})
        item_subs = kwargs.pop('item_subs', {})
        extra_defaults = OrderedDict([
            ('CVC', '0'),
            ('code', ''),
            ('name', ''),
            ('fullname', ''),
            ('description', ''),
            ('HTML Description', ''),
            ('imglist', [])
        ])
        extra_taxo_subs = OrderedDict([
            ('', ''),
        ])
        extra_item_subs = OrderedDict([
            ('Hot Pink', 'Pink'),
            ('Hot Lips (Red)', 'Red'),
            ('Hot Lips', 'Red'),
            ('Silken Chocolate (Bronze)', 'Bronze'),
            ('Silken Chocolate', 'Bronze'),
            ('Moon Marvel (Silver)', 'Silver'),
            ('Dusty Gold', 'Gold'),

            ('Screen Printed', ''),
            ('Embroidered', ''),
        ])
        extra_cols = [schema]

        cols = listUtils.combine_lists(cols, extra_cols)
        defaults = listUtils.combine_ordered_dicts(defaults, extra_defaults)
        super(CSVParse_Gen_Tree, self).__init__(cols, defaults, **kwargs)
        # CSVParse_Gen_Mixin.__init__(self, schema)

        meta_width = kwargs.get('meta_width', 2)
        assert meta_width >= 2, "meta_width must be greater than 2 for a GEN subclass"

        self.schema = schema
        self.taxo_subs = listUtils.combine_ordered_dicts(taxo_subs, extra_taxo_subs)
        self.item_subs = listUtils.combine_ordered_dicts(item_subs, extra_item_subs)
        self.taxoRegex = SanitationUtils.compile_regex(self.taxo_subs)
        self.itemRegex = SanitationUtils.compile_regex(self.item_subs)

        if self.DEBUG_GEN:
            self.registerMessage("taxoDepth: {}".format(
                self.taxoDepth), 'CSVParse_Gen_Tree.__init__')
            self.registerMessage("itemDepth: {}".format(
                self.itemDepth), 'CSVParse_Gen_Tree.__init__')
            self.registerMessage("maxDepth: {}".format(
                self.maxDepth), 'CSVParse_Gen_Tree.__init__')
            self.registerMessage("meta_width: {}".format(
                self.meta_width), 'CSVParse_Gen_Tree.__init__')
            self.registerMessage("schema: {}".format(
                self.schema), 'CSVParse_Gen_Tree.__init__')

    def getNewObjContainer(self, all_data, **kwargs):
        if self.DEBUG_MRO:
            self.registerMessage(' ')
        container = super(CSVParse_Gen_Tree, self).getNewObjContainer(
            all_data, **kwargs)
        if issubclass(container, ImportTreeItem):
            if self.DEBUG_GEN:
                self.registerMessage("super resulted in item container")
            itemtype = all_data.get(self.schema, '')
            if self.DEBUG_GEN:
                self.registerMessage("itemtype: {}".format(itemtype))
            if itemtype in self.containers.keys():
                container = self.containers[itemtype]
        else:
            if self.DEBUG_GEN:
                self.registerMessage("super resulted in non-item container")
        return container

    def getParserData(self, **kwargs):
        super_data = CSVParse_Gen_Mixin.getParserData(self, **kwargs)
        super_data.update(CSVParse_Tree.getParserData(self, **kwargs))
        return super_data

    # def clear_transients(self):
    #     super(CSVParse_Gen_Tree, self).clear_transients()
        # CSVParse_Shop.clear_transients(self)

    # def registerItem(self, itemData):
    #     super(CSVParse_Gen_Tree, self).registerItem(itemData)
    #     if itemData.isProduct:
    #         self.registerProduct(itemData)

    def change_item(self, item):
        return SanitationUtils.shorten(self.itemRegex, self.item_subs, item)

    def change_fullname(self, item):
        subs = OrderedDict([(' \xe2\x80\x94 ', ' ')])
        return SanitationUtils.shorten(
            SanitationUtils.compile_regex(subs), subs, item)

    def getKwargs(self, all_data, container, **kwargs):
        if self.DEBUG_MRO:
            self.registerMessage(' ')
        kwargs = super(CSVParse_Gen_Tree, self).getKwargs(
            all_data, container, **kwargs)
        assert issubclass(container, ImportGenObject)
        if issubclass(container, self.taxoContainer):
            regex = self.taxoRegex
            subs = self.taxo_subs
        else:
            assert issubclass(
                container, self.itemContainer), "class must be item or taxo subclass not %s" % container.__name__
            regex = self.itemRegex
            subs = self.item_subs
        kwargs['regex'] = regex
        kwargs['subs'] = subs
        for key in ['regex', 'subs']:
            assert kwargs[key] is not None
        return kwargs

    # def newObject(self, rowcount, row, **kwargs):
    # return super(CSVParse_Gen_Tree, self).newObject(rowcount, row, **kwargs)
