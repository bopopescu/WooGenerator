"""
CsvParseGenTree
Introduces the "Generator" structure to the heirarchical CSV parser class CsvParseTree.

The Generator structure attaches metadata like code, name and description for all objects.
In heirarchical structures, the metadata for an object is generated by ananlysing its ancestors.
"""

from __future__ import absolute_import

from collections import OrderedDict
from pprint import pformat

from ..utils import DescriptorUtils, Registrar, SanitationUtils, SeqUtils
from .tree import (CsvParseTree, ImportTreeItem, ImportTreeObject,
                   ImportTreeTaxo)


class ImportGenMixin(object):
    "Provides basic Generator interface for Import classes as a mixin"
    codesum_key = 'codesum'
    descsum_key = 'descsum'
    namesum_key = 'itemsum'
    namesum = DescriptorUtils.safe_key_property(namesum_key)
    codesum = DescriptorUtils.safe_key_property(codesum_key)
    descsum = DescriptorUtils.safe_key_property(descsum_key)

    verify_meta_keys = [
        codesum_key,
        descsum_key,
    ]

    @property
    def index(self):
        index = self.codesum
        super_obj = super(ImportGenMixin, self)
        if hasattr(super_obj, 'index'):
            index = '|'.join(SeqUtils.filter_unique_true([
                super_obj.index,
                index
            ]))
        return index

    def __str__(self):
        return "%10s <%s>" % (
            '|'.join(i for i in [self.codesum, self.namesum] if i), self.type_name)


class ImportGenObject(ImportTreeObject, ImportGenMixin):
    "Base class for heirarchical generator classes"

    code_key = 'code'
    name_key = 'name'
    fullname_key = 'fullname'
    description_key = 'HTML Description'
    fullnamesum_key = 'fullnamesum'

    verify_meta_keys = SeqUtils.combine_lists(
        ImportTreeObject.verify_meta_keys,
        ImportGenMixin.verify_meta_keys
    )

    code = DescriptorUtils.safe_key_property(code_key)
    name = DescriptorUtils.safe_key_property(name_key)
    fullname = DescriptorUtils.safe_key_property(fullname_key)
    description = DescriptorUtils.safe_key_property(description_key)
    fullnamesum = DescriptorUtils.safe_key_property(fullnamesum_key)

    name_delimeter = ' '

    index = ImportGenMixin.index

    def __init__(self, *args, **kwargs):
        self.subs = kwargs.pop('subs', {})
        self.regex = kwargs.pop('regex', {})
        ImportTreeObject.__init__(self, *args, **kwargs)
        if self.DEBUG_GEN:
            self.register_message("dict is now %s" % (
                pformat(self.to_dict().items())
            ))

    @property
    def name_ancestors(self):
        return self.ancestors

    def get_code_delimeter(self, other):  # pylint: disable=no-self-use,unused-argument
        return ''

    def join_codes(self, ancestors):
        code_ancestors = [
            ancestor for ancestor in ancestors + [self] if ancestor.code]
        if not code_ancestors:
            return ""
        prev = code_ancestors.pop(0)
        codesum = prev.code
        while code_ancestors:
            this = code_ancestors.pop(0)
            codesum += this.get_code_delimeter(prev) + this.code
            prev = this
        return codesum

    def join_descs(self, ancestors):
        ancestors_self = ancestors + [self]

        if self.DEBUG_GEN:
            self.register_message(
                u"given description: {}".format(self.description))
            self.register_message(u"self: {}".format(self.items()))
        if self.description:
            return self.description
        fullnames = [self.fullname]

        for ancestor in reversed(ancestors_self):
            ancestor_description = ancestor.description
            if ancestor_description:
                return ancestor_description
            if not getattr(ancestor, 'is_item'):
                continue
            ancestor_fullname = SanitationUtils.strip_extra_whitespace(ancestor.fullname)
            if ancestor_fullname:
                fullnames.insert(0, ancestor_fullname)
        if fullnames:
            return " - ".join(SeqUtils.filter_unique_true(fullnames))
        else:
            return ""

    def join_names(self, ancestors):
        ancestors_self = ancestors + [self]
        names = SeqUtils.filter_unique_true(
            map(lambda x: x.name, ancestors_self))
        name_delimeter = self.name_delimeter
        return name_delimeter.join(names)

    def join_fullnames(self, ancestors):
        ancestors_self = ancestors + [self]
        names = SeqUtils.filter_unique_true(
            map(lambda x: x.fullname, ancestors_self))
        name_delimeter = self.name_delimeter
        return name_delimeter.join(names)

    def change_name(self, name):
        return SanitationUtils.shorten(self.regex, self.subs, name)

    def process_meta(self):
        meta = self.meta

        if not self.fullname:
            try:
                self.fullname = meta[0]
            except IndexError:
                self.fullname = ""

        if not self.code:
            try:
                self.code = meta[1]
            except IndexError:
                self.code = ""

        ancestors = self.ancestors
        if self.DEBUG_GEN:
            self.register_message('ancestors:')
            for ancestor in ancestors:
                self.register_message(u"-> {}".format(ancestor))

        if not self.codesum:
            codesum = self.join_codes(ancestors)
            if self.DEBUG_GEN:
                self.register_message(u"codesum: {}".format(codesum))
            self.codesum = codesum

        if not self.descsum:
            descsum = self.join_descs(ancestors)
            if self.DEBUG_GEN:
                self.register_message(u"descsum: {}".format(descsum))
            self.descsum = descsum

        # if self.descsum and not self.description:
        #     self.description = self.descsum

        if not self.name:
            name = self.change_name(self.fullname)
            if self.DEBUG_GEN:
                self.register_message(u"name: {}".format(name))
            self.name = name

        name_ancestors = self.name_ancestors
        if not self.namesum:
            namesum = self.join_names(name_ancestors)
            if self.DEBUG_GEN:
                self.register_message(u"namesum: {}".format(namesum))
            self.namesum = namesum

        if not self.fullnamesum:
            fullnamesum = self.join_fullnames(name_ancestors)
            if self.DEBUG_GEN:
                self.register_message(u"fullnamesum: {}".format(fullnamesum))
            self.fullnamesum = fullnamesum


class ImportGenItem(ImportGenObject, ImportTreeItem):
    "Class for items in generator heirarchy"

    verify_meta_keys = SeqUtils.combine_lists(
        ImportGenObject.verify_meta_keys,
        [ImportGenObject.namesum_key]
    )

    @property
    def name_ancestors(self):
        return self.item_ancestors

    def get_name_ancestors(self):
        exc = DeprecationWarning(
            "use .name_ancestors instead of .get_name_ancestors()")
        self.register_error(exc)
        return self.name_ancestors
        # return self.getItemAncestors()

    def get_code_delimeter(self, other):
        assert issubclass(type(other), ImportGenObject)
        if not other.is_root and other.is_taxo:
            return '-'
        else:
            return super(ImportGenItem, self).get_code_delimeter(other)


class ImportGenTaxo(ImportGenObject, ImportTreeTaxo):

    namesum_key = 'taxosum'
    namesum = DescriptorUtils.safe_key_property(namesum_key)

    verify_meta_keys = SeqUtils.combine_lists(
        ImportGenObject.verify_meta_keys,
        [namesum_key]
    )
    verify_meta_keys.remove(ImportGenMixin.codesum_key)

    name_delimeter = ' > '

    def get_name_delimeter(self):
        exc = DeprecationWarning(
            "use .name_delimeter instead of .get_name_delimeter()")
        self.register_error(exc)
        return ' > '


class CsvParseGenMixin(object):
    """
    Mixin class for parsers with generator interface
    """
    object_container = ImportGenObject
    taxo_container = ImportGenTaxo
    item_container = ImportGenItem
    # product_container = ImportGenProduct
    containers = {}

    @classmethod
    def get_code_sum(cls, object_data):
        assert issubclass(type(object_data), ImportGenMixin)
        return object_data.codesum

    @classmethod
    def get_name_sum(cls, object_data):
        assert issubclass(type(object_data), ImportGenMixin)
        return object_data.namesum

    @classmethod
    def get_full_name_sum(cls, object_data):
        assert issubclass(type(object_data), ImportGenObject)
        return object_data.fullnamesum

    @classmethod
    def sanitize_cell(cls, cell):
        return SanitationUtils.sanitize_cell(cell)

    def get_defaults(self, **kwargs):
        return {
            self.object_container.namesum_key: '',
            self.object_container.codesum_key: '',
            self.object_container.descsum_key: ''
        }

class CsvParseGenTree(CsvParseTree, CsvParseGenMixin):
    """ Parser for tree-based generator structure """

    sanitize_cell = CsvParseGenMixin.sanitize_cell
    object_container = CsvParseGenMixin.object_container
    taxo_container = CsvParseGenMixin.taxo_container
    item_container = CsvParseGenMixin.item_container

    def __init__(self, cols, defaults, schema, **kwargs):
        taxo_subs = kwargs.pop('taxo_subs', {})
        item_subs = kwargs.pop('item_subs', {})

        kwargs['meta_width'] = kwargs.get('meta_width', 2)
        assert kwargs['meta_width'] >= 2, "meta_width must be greater than 2 for a GEN subclass"

        CsvParseTree.__init__(self, cols, defaults, **kwargs)
        # CsvParseGenMixin.__init__(self, schema)

        self.schema = schema
        self.taxo_subs = taxo_subs
        self.item_subs = item_subs
        self.taxo_regex = SanitationUtils.compile_regex(self.taxo_subs)
        self.item_regex = SanitationUtils.compile_regex(self.item_subs)

        if self.DEBUG_GEN:
            self.register_message("taxo_depth: {}".format(
                self.taxo_depth), 'CsvParseGenTree.__init__')
            self.register_message("item_depth: {}".format(
                self.item_depth), 'CsvParseGenTree.__init__')
            self.register_message("max_depth: {}".format(
                self.max_depth), 'CsvParseGenTree.__init__')
            self.register_message("meta_width: {}".format(
                self.meta_width), 'CsvParseGenTree.__init__')
            self.register_message("schema: {}".format(
                self.schema), 'CsvParseGenTree.__init__')

    def get_new_obj_container(self, all_data, **kwargs):
        container = super(CsvParseGenTree, self).get_new_obj_container(
            all_data, **kwargs)
        if issubclass(container, ImportTreeItem):
            if self.DEBUG_GEN:
                self.register_message("super resulted in item container")
            itemtype = all_data.get(self.schema, '')
            if self.DEBUG_GEN:
                self.register_message("itemtype: {}".format(itemtype))
            if itemtype in self.containers.keys():
                container = self.containers[itemtype]
        return container

    def get_defaults(self, **kwargs):
        defaults = {}
        for base_class in CsvParseGenTree.__bases__:
            if hasattr(base_class, 'get_defaults'):
                defaults.update(base_class.get_defaults(self, **kwargs))
        return defaults

    def change_item(self, item):
        return SanitationUtils.shorten(self.item_regex, self.item_subs, item)

    def change_fullname(self, item):  # pylint: disable=no-self-use
        subs = OrderedDict([(' \xe2\x80\x94 ', ' ')])
        return SanitationUtils.shorten(
            SanitationUtils.compile_regex(subs), subs, item)

    def get_kwargs(self, all_data, **kwargs):
        kwargs = super(CsvParseGenTree, self).get_kwargs(
            all_data, **kwargs)
        regex = kwargs.pop('regex', None)
        subs = kwargs.pop('subs', None)
        if issubclass(kwargs['container'], self.taxo_container):
            regex = self.taxo_regex
            subs = self.taxo_subs
        elif issubclass(kwargs['container'], self.item_container):
            regex = self.item_regex
            subs = self.item_subs
        kwargs['regex'] = regex
        kwargs['subs'] = subs
        return kwargs

    # def new_object(self, rowcount, row, **kwargs):
    # return super(CsvParseGenTree, self).new_object(rowcount, row, **kwargs)
